// index.js - Backend with MongoDB & RECURRING Stripe Subscriptions

const express = require("express");
const axios = require("axios");
const cors = require("cors");
const path = require("path");
// const { v4: uuidv4 } = require("uuid"); // Mongoose _id used for jobs
const stripePackage = require("stripe");
const mongoose = require("mongoose");

const app = express();
app.use(express.static(path.join(__dirname, "."))); // For optional success/cancel pages

// --- Environment Variables ---
const APIFY_TOKEN = process.env.APIFY_TOKEN;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY;
const STRIPE_WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET;
const STRIPE_LITE_PLAN_PRICE_ID = process.env.STRIPE_LITE_PLAN_PRICE_ID; // RECURRING
const STRIPE_PRO_PLAN_PRICE_ID = process.env.STRIPE_PRO_PLAN_PRICE_ID;   // RECURRING
const FRONTEND_URL = process.env.FRONTEND_URL || "https://example.com";   // Important for Stripe redirects
const YOUR_EXTENSION_ID = process.env.YOUR_EXTENSION_ID;                  // For CORS
const MONGODB_URI = process.env.MONGO_URL;

// --- Configuration ---
const APIFY_BATCH_SIZE = 1000;
const JOB_TTL_MINUTES = 2 * 24 * 60; // 2 days for job document expiry
const JOB_TTL_MS = JOB_TTL_MINUTES * 60 * 1000;
const OPENAI_CHAT_COMPLETIONS_URL = "https://api.openai.com/v1/chat/completions";
const CREDITS_FOR_LITE_PLAN = 750; // Credits per Lite plan successful payment
const CREDITS_FOR_PRO_PLAN = 2000;  // Credits per Pro plan successful payment

// --- Validate Critical Environment Variables ---
if (!OPENAI_API_KEY) { console.error("FATAL ERROR: OPENAI_API_KEY missing!"); process.exit(1); }
if (!STRIPE_SECRET_KEY) { console.error("FATAL ERROR: STRIPE_SECRET_KEY missing!"); process.exit(1); }
if (!STRIPE_WEBHOOK_SECRET) { console.error("FATAL ERROR: STRIPE_WEBHOOK_SECRET missing!"); process.exit(1); }
if (!STRIPE_LITE_PLAN_PRICE_ID) { console.error("FATAL ERROR: STRIPE_LITE_PLAN_PRICE_ID missing!"); process.exit(1); }
if (!STRIPE_PRO_PLAN_PRICE_ID) { console.error("FATAL ERROR: STRIPE_PRO_PLAN_PRICE_ID missing!"); process.exit(1); }
if (!MONGODB_URI) { console.error("FATAL ERROR: MONGODB_URI missing!"); process.exit(1); }
if (!YOUR_EXTENSION_ID) { console.warn("WARNING: YOUR_EXTENSION_ID missing in env vars. CORS might fail."); }
if (!APIFY_TOKEN) { console.warn("WARNING: APIFY_TOKEN missing. Scraping functionality will be limited/skipped."); }
if (FRONTEND_URL === "https://example.com") { console.warn("WARNING: FRONTEND_URL is set to default 'https://example.com'. Stripe redirects might not work as expected."); }

const stripe = stripePackage(STRIPE_SECRET_KEY);

// --- MongoDB Connection ---
mongoose.connect(MONGODB_URI, {
  serverApi: { version: mongoose.mongo.ServerApiVersion.v1, strict: true, deprecationErrors: true }
})
.then(() => console.log("[DB] MongoDB Connected Successfully"))
.catch(err => { console.error("[DB] FATAL ERROR: MongoDB Connection Failed!", err); process.exit(1); });

mongoose.connection.on('connected', () => console.log('[DB] Mongoose connected to DB cluster:', mongoose.connection.host));
mongoose.connection.on('error', (err) => console.error('[DB] Mongoose connection error:', err));
mongoose.connection.on('disconnected', () => console.log('[DB] Mongoose disconnected from DB cluster.'));


// --- Mongoose Schemas and Models ---
const userSchema = new mongoose.Schema({
    userId: { type: String, required: true, unique: true, index: true }, // From Chrome Extension
    credits: { type: Number, required: true, default: 0, min: 0 },
    email: { type: String, trim: true, sparse: true }, // User's email, if captured
    stripeCustomerId: { type: String, unique: true, sparse: true, index: true }, // Stripe Customer ID
    stripeSubscriptionId: { type: String, unique: true, sparse: true, index: true }, // Active Stripe Subscription ID
    stripeSubscriptionStatus: { type: String, enum: ['active', 'past_due', 'unpaid', 'canceled', 'incomplete', 'incomplete_expired', 'trialing', 'paused', null], default: null },
    currentPlanPriceId: { type: String }, // Stripe Price ID of the current active plan
    lastProcessedEventId: { type: String } // For Stripe webhook idempotency
}, { timestamps: true }); // Adds createdAt and updatedAt
const User = mongoose.model("User", userSchema);

const jobSchema = new mongoose.Schema({
    // _id (jobId) will be auto-generated by Mongoose
    userId: { type: String, required: true, index: true },
    status: { type: String, required: true, enum: ['PENDING', 'RUNNING_SCRAPE', 'RUNNING_AI', 'COMPLETE', 'ERROR'], default: 'PENDING', index: true },
    params: { type: Object, required: true }, // Original generation parameters
    result: { // Final sequences, warnings, and credit count at completion/error
        sequences: { type: Array },
        warnings: { type: Array },
        newCredits: { type: Number }
    },
    error: { type: String }, // Error message if job status is ERROR
    progress: {
        total: { type: Number, default: 0 },
        processed: { type: Number, default: 0 },
        status: { type: String, default: 'Pending Start' } // Textual progress status
    },
    estimatedTimeMs: { type: Number },
    completedAt: { type: Date }, // Timestamp when job finished
    expiresAt: { type: Date, required: true, index: { expires: '0s' } } // For MongoDB TTL cleanup
}, { timestamps: true });
const Job = mongoose.model('Job', jobSchema);
console.log("[Schema] Job Schema with TTL index defined.");

const logSchema = new mongoose.Schema({
    timestamp: { type: Date, default: Date.now, index: true },
    level: { type: String, enum: ['INFO', 'WARN', 'ERROR', 'DEBUG'], required: true },
    message: { type: String, required: true },
    jobId: { type: String, index: true },
    userId: { type: String, index: true },
    metadata: { type: Object }, // For extra context like error stacks
    // Optional: logExpiresAt: { type: Date, index: { expires: '90d' } } // Keep logs for 90 days
});
const Log = mongoose.model('Log', logSchema);
console.log("[Schema] Log Schema defined.");

// --- Logging Helper ---
async function logDb(level, message, details = {}) {
    const consoleArgs = [
        `[${new Date().toISOString()}] [${level}]`,
        details.jobId ? `[Job:${details.jobId.toString().slice(-6)}]` : '',
        details.userId ? `[User:${details.userId.slice(-6)}]` : '',
        message
    ].filter(Boolean).join(' ');

    if (level === 'ERROR') console.error(consoleArgs, details.metadata || '');
    else if (level === 'WARN') console.warn(consoleArgs, details.metadata || '');
    else console.log(consoleArgs);

    const logEntry = new Log({
        level: level, message: message, jobId: details.jobId,
        userId: details.userId, metadata: details.metadata
    });
    logEntry.save().catch(err => {
        console.error("!!! MongoDB Log Save Failed !!!", err, { level, message, details });
    });
}

// --- CORS Configuration ---
const extensionOrigin = YOUR_EXTENSION_ID ? `chrome-extension://${YOUR_EXTENSION_ID}` : null;
const corsOptions = {
    origin: function (origin, callback) {
        const allowedOrigins = [
            extensionOrigin, "https://replit.com",
            process.env.REPL_SLUG ? `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.replit.dev` : null,
            process.env.REPL_DEV_DOMAIN ? `https://${process.env.REPL_DEV_DOMAIN}` : null,
            FRONTEND_URL
        ].filter(Boolean);
        if (!origin || allowedOrigins.includes(origin)) callback(null, true);
        else {
            logDb('WARN', `CORS Blocked Origin: ${origin}`, { metadata: { allowed: allowedOrigins.join(', ') } });
            callback(new Error(`Origin ${origin} not allowed by CORS`));
        }
    },
    methods: ["POST", "GET", "OPTIONS"], allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
    credentials: true, optionsSuccessStatus: 200,
};
app.use(cors(corsOptions));
console.log(`[Config] CORS enabled. Extension origin: ${extensionOrigin || "NOT SET!"}`);


// --- Stripe Webhook Endpoint (for Subscriptions) ---
app.post("/stripe-webhook", express.raw({ type: 'application/json' }), async (req, res) => {
    const sig = req.headers['stripe-signature'];
    let event;
    const webhookEndpoint = '/stripe-webhook';

    try {
        event = stripe.webhooks.constructEvent(req.body, sig, STRIPE_WEBHOOK_SECRET);
        logDb('INFO', `Webhook Received: ${event.type} ID: ${event.id}`, { metadata: { endpoint: webhookEndpoint } });
    } catch (err) {
        logDb('ERROR', `Webhook signature verification failed: ${err.message}`, { metadata: { endpoint: webhookEndpoint, errorDetails: err.message } });
        return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    let userId;
    let stripeCustomerId;
    let subscriptionObj;

    if (event.type === 'checkout.session.completed') {
        const session = event.data.object;
        userId = session.client_reference_id;
        stripeCustomerId = session.customer;
        if (userId && stripeCustomerId) {
            try {
                // Ensure user exists and link Stripe Customer ID
                await User.findOneAndUpdate(
                    { userId: userId },
                    { $set: { stripeCustomerId: stripeCustomerId }, $setOnInsert: { userId: userId, credits: 0 } }, // credits:0 only on insert
                    { upsert: true, new: true }
                );
                logDb('INFO', `Linked/Updated Stripe Customer ID from checkout.session.completed`, { userId, stripeCustomerId, eventId: event.id });
            } catch (dbError) { logDb('ERROR', `DB error linking Stripe Customer ID from checkout: ${dbError.message}`, { userId, eventId: event.id, error: dbError });}
        } else {
             logDb('ERROR', `checkout.session.completed missing userId or customerId. Session: ${session.id}`, { eventId: event.id });
        }
    } else if (event.data.object.customer) {
        stripeCustomerId = event.data.object.customer;
        const userByCustId = await User.findOne({ stripeCustomerId: stripeCustomerId });
        if (userByCustId) userId = userByCustId.userId;
        else {
            logDb('WARN', `Webhook for unknown Stripe Customer: ${stripeCustomerId}. Event: ${event.type}`, { eventId: event.id });
            return res.status(200).json({ received: true, note: "User not found for customer ID" });
        }
    } else if (event.data.object.id && event.type.startsWith('plan.') || event.type.startsWith('product.')) {
        // Plan/Product events don't have a customer object directly. We can ignore them for user updates or log them.
        logDb('DEBUG', `Ignoring plan/product event: ${event.type}`, { eventId: event.id });
        return res.status(200).json({ received: true, note: "Plan/Product event ignored for user updates." });
    }
    else {
        logDb('WARN', `Could not determine customer/user for event ${event.type}`, { eventId: event.id, eventData: JSON.stringify(event.data.object).substring(0, 200) });
        return res.status(200).json({ received: true, note: "Could not identify user from event data" });
    }


    if (userId) {
        const userForIdempotency = await User.findOne({ userId: userId });
        if (userForIdempotency && userForIdempotency.lastProcessedEventId === event.id) {
            logDb('INFO', `Event ${event.id} already processed for user ${userId}. Skipping.`, { userId });
            return res.status(200).json({ received: true, status: 'already_processed' });
        }
    } else if (event.type !== 'checkout.session.completed') {
         logDb('ERROR', `UserId could not be determined for idempotency check and processing of event ${event.type}, ID ${event.id}.`, {stripeCustomerId});
         return res.status(200).json({ received: true, error: "User ID could not be determined for this event." });
    }


    try {
        switch (event.type) {
            case 'customer.subscription.created':
                subscriptionObj = event.data.object;
                logDb('INFO', `Subscription Created: ${subscriptionObj.id}, Status: ${subscriptionObj.status}`, { userId, subId: subscriptionObj.id, eventId: event.id });
                await User.findOneAndUpdate(
                    { userId: userId },
                    { $set: {
                        stripeSubscriptionId: subscriptionObj.id,
                        stripeSubscriptionStatus: subscriptionObj.status,
                        currentPlanPriceId: subscriptionObj.items.data[0].price.id,
                        lastProcessedEventId: event.id
                    }}, { new: true, upsert: true } // Upsert just in case user was missed by checkout.session
                );
                break;

            case 'customer.subscription.updated':
                subscriptionObj = event.data.object;
                logDb('INFO', `Subscription Updated: ${subscriptionObj.id}, Status: ${subscriptionObj.status}`, { userId, subId: subscriptionObj.id, eventId: event.id });
                const updateFields = {
                    stripeSubscriptionStatus: subscriptionObj.status,
                    currentPlanPriceId: subscriptionObj.items.data[0].price.id, // Ensure this is always updated
                    lastProcessedEventId: event.id
                };
                await User.findOneAndUpdate({ userId: userId, stripeSubscriptionId: subscriptionObj.id }, { $set: updateFields });
                if (['canceled', 'unpaid', 'past_due'].includes(subscriptionObj.status)) {
                    logDb('INFO', `Subscription for ${userId} is now ${subscriptionObj.status}. Review access/credits.`, { userId, subId: subscriptionObj.id, eventId: event.id });
                }
                break;

            case 'customer.subscription.deleted': // Subscription fully ended (after cancel_at_period_end or immediate)
                subscriptionObj = event.data.object;
                logDb('INFO', `Subscription Deleted: ${subscriptionObj.id}`, { userId, subId: subscriptionObj.id, eventId: event.id });
                await User.findOneAndUpdate(
                    { userId: userId, stripeSubscriptionId: subscriptionObj.id },
                    { $set: { stripeSubscriptionStatus: 'canceled', lastProcessedEventId: event.id }} // Mark as canceled definitively
                );
                // Optionally: set credits to 0 if policy dictates immediate loss of unused credits
                // await User.updateOne({ userId: userId, stripeSubscriptionId: subscriptionObj.id }, { $set: { credits: 0 } });
                break;

            case 'invoice.payment_succeeded':
                const invoice = event.data.object;
                if (!invoice.subscription) {
                    logDb('INFO', `Invoice ${invoice.id} payment succeeded but no subscription associated (e.g., one-time).`, { userId, eventId: event.id });
                    if(userId) await User.updateOne({ userId: userId }, { $set: { lastProcessedEventId: event.id } });
                    break;
                }
                subscriptionObj = await stripe.subscriptions.retrieve(invoice.subscription);

                if (['subscription_create', 'subscription_cycle', 'subscription_update'].includes(invoice.billing_reason)) {
                    const planPriceId = subscriptionObj.items.data[0].price.id;
                    let creditsToAdd = 0;
                    if (planPriceId === STRIPE_LITE_PLAN_PRICE_ID) creditsToAdd = CREDITS_FOR_LITE_PLAN;
                    else if (planPriceId === STRIPE_PRO_PLAN_PRICE_ID) creditsToAdd = CREDITS_FOR_PRO_PLAN;
                    else logDb('WARN', `Unknown planPriceId ${planPriceId} on successful invoice ${invoice.id}`, { userId, subId: subscriptionObj.id, eventId: event.id });

                    if (creditsToAdd > 0) {
                        const updatedUser = await User.findOneAndUpdate(
                            { userId: userId },
                            { $inc: { credits: creditsToAdd }, $set: {
                                stripeSubscriptionStatus: 'active', // Ensure status reflects active after payment
                                currentPlanPriceId: planPriceId,
                                stripeSubscriptionId: subscriptionObj.id, // Ensure sub ID is correctly associated
                                lastProcessedEventId: event.id
                            }}, { new: true, upsert: true } // Upsert in case the user document was missed somehow
                        );
                        logDb('INFO', `Invoice paid. Added ${creditsToAdd} credits. New balance: ${updatedUser?.credits}`, { userId, subId: subscriptionObj.id, eventId: event.id });
                    } else { // Unknown plan, but payment succeeded
                        if(userId) await User.updateOne({ userId: userId }, { $set: { lastProcessedEventId: event.id } });
                    }
                }
                break;

            case 'invoice.payment_failed':
                const failedInvoice = event.data.object;
                logDb('WARN', `Invoice Payment Failed: ${failedInvoice.id}. Subscription: ${failedInvoice.subscription}`, { userId, eventId: event.id });
                if (failedInvoice.subscription && userId) { // Ensure userId is available
                    await User.findOneAndUpdate(
                        { userId: userId, stripeSubscriptionId: failedInvoice.subscription },
                        { $set: { stripeSubscriptionStatus: 'past_due', lastProcessedEventId: event.id } }
                    );
                } else if (userId) { // If no subscription but we have a user (e.g. one-time payment failed)
                    await User.updateOne({ userId: userId }, { $set: { lastProcessedEventId: event.id } });
                }
                break;

            case 'checkout.session.completed':
                 logDb('INFO', `Checkout session ${event.data.object.id} completed. Customer ID already linked, or will be by subscription events. Marking event processed.`, { userId, eventId: event.id });
                 if(userId) await User.updateOne({ userId: userId }, { $set: { lastProcessedEventId: event.id } });
                 break;

            default:
                logDb('DEBUG', `Unhandled event type ${event.type}, ID: ${event.id}`, { userId, eventId: event.id });
                if(userId) await User.updateOne({ userId: userId }, { $set: { lastProcessedEventId: event.id } });
        }
    } catch (dbError) {
        logDb('ERROR', `Webhook DB/processing error for event ${event.id} (${event.type}): ${dbError.message}`, { userId, errorDetails: dbError.stack, eventId: event.id });
        return res.status(500).send(`Webhook Error: ${dbError.message}`); // Let Stripe retry
    }

    res.status(200).json({ received: true });
});

app.use(express.json());

// --- Helper Functions ---
function escape(str) {
    if (str === null || str === undefined) return "";
    return String(str).replace(/`/g, "'").replace(/\\/g, "\\\\").replace(/\n/g, " ").replace(/"/g, '""');
}
const nichePrompts = { /* ... (Keep your existing large nichePrompts object here) ... */ };
function constructOpenAIPrompt(generationParams, scrapedProfileData) { /* ... (Keep your existing function here, ensure it uses logDb if needed) ... */ }
function parseOpenAIResponse(rawContent, expectedCount) { /* ... (Keep your existing function here, ensure it uses logDb if needed) ... */ }
async function performGeneration(jobId, generationParams, userId) { /* ... (Keep your existing function here, ensure it uses logDb for all console logs) ... */ }

// --- Endpoint to Get User Data (Credits & Subscription Info) ---
app.get("/user-data/:userId", async (req, res) => {
    const { userId } = req.params;
    const endpoint = `/user-data/${userId}`;
    logDb('INFO', `User data request`, { userId, metadata: { endpoint } });
    try {
        let user = await User.findOne({ userId: userId });
        if (!user) {
            logDb('INFO', `User not found, creating...`, { userId, metadata: { endpoint } });
            user = new User({ userId: userId, credits: 0 });
            await user.save();
            logDb('INFO', `User created with 0 credits.`, { userId, metadata: { endpoint } });
        }
        res.status(200).json({
            success: true,
            userId: user.userId,
            credits: user.credits,
            stripeSubscriptionStatus: user.stripeSubscriptionStatus,
            currentPlanPriceId: user.currentPlanPriceId,
            hasStripeCustomer: !!user.stripeCustomerId
        });
    } catch (dbError) {
        logDb('ERROR', `DB error fetching user data: ${dbError.message}`, { userId, metadata: { endpoint, error: dbError } });
        res.status(500).json({ success: false, error: "Internal server error fetching user data." });
    }
});

// --- Endpoint to Create Stripe Checkout Session (FOR SUBSCRIPTIONS) ---
app.post("/create-checkout-session", async (req, res) => {
    const { userId, planPriceId } = req.body; // `planPriceId` from frontend
    const endpoint = '/create-checkout-session';
    logDb('INFO', `Subscription checkout request for plan: ${planPriceId}`, { userId, metadata: { endpoint } });

    if (!userId) return res.status(400).json({ success: false, error: "Missing userId." });
    if (!planPriceId) return res.status(400).json({ success: false, error: "Missing planPriceId." });
    if (planPriceId !== STRIPE_LITE_PLAN_PRICE_ID && planPriceId !== STRIPE_PRO_PLAN_PRICE_ID) {
        logDb('ERROR', `Invalid planPriceId: ${planPriceId}`, { userId, metadata: { endpoint } });
        return res.status(400).json({ success: false, error: "Invalid subscription plan selected." });
    }

    const successUrl = `${FRONTEND_URL}/popup/index.html#paymentSuccess`; // Example, adjust as needed
    const cancelUrl = `${FRONTEND_URL}/popup/index.html#paymentCancel`;   // Example, adjust as needed

    try {
        let user = await User.findOne({ userId: userId });
        if (!user) { // Create user if they don't exist (e.g., first interaction is to subscribe)
            user = new User({ userId: userId });
            await user.save();
            logDb('INFO', `User document auto-created during checkout initiation for ${userId}`, { userId, metadata: { endpoint }});
        }
        let stripeCustomerId = user.stripeCustomerId;
        if (!stripeCustomerId) {
            const customer = await stripe.customers.create({
                name: `Sulian User ${userId.slice(-6)}`, // Example, can use email if you have it
                metadata: { app_user_id: userId }
            });
            stripeCustomerId = customer.id;
            user.stripeCustomerId = stripeCustomerId;
            await user.save();
            logDb('INFO', `Stripe Customer created: ${stripeCustomerId} for user ${userId}`, { userId, metadata: { endpoint } });
        }

        // Check for existing active subscription
        if (user.stripeSubscriptionId && (user.stripeSubscriptionStatus === 'active' || user.stripeSubscriptionStatus === 'trialing')) {
            logDb('WARN', `User ${userId} already has an active/trialing subscription: ${user.stripeSubscriptionId}. Suggesting portal.`, { metadata: { endpoint } });
            return res.status(409).json({ // 409 Conflict
                success: false,
                error: "You already have an active subscription. Please manage it via the customer portal.",
                action: "manage_subscription" // UI can use this to guide user
            });
        }

        const session = await stripe.checkout.sessions.create({
            mode: 'subscription',
            payment_method_types: ['card'],
            customer: stripeCustomerId,
            line_items: [{ price: planPriceId, quantity: 1 }],
            success_url: successUrl,
            cancel_url: cancelUrl,
            subscription_data: { metadata: { app_user_id: userId, plan_price_id: planPriceId } },
            client_reference_id: userId // Useful for initial linking if checkout.session.completed comes first
        });
        logDb('INFO', `Stripe Subscription Checkout Session created: ${session.id}`, { userId, metadata: { endpoint, sessionId: session.id } });
        res.status(200).json({ success: true, url: session.url });
    } catch (error) {
        logDb('ERROR', `Error creating Stripe subscription checkout: ${error.message}`, { userId, metadata: { endpoint, errorDetails: error.stack } });
        res.status(500).json({ success: false, error: `Failed to create checkout session: ${error.message}` });
    }
});

// --- Endpoint to Create Stripe Customer Portal Session ---
app.post("/create-customer-portal-session", async (req, res) => {
    const { userId } = req.body;
    const endpoint = '/create-customer-portal-session';
    logDb('INFO', `Customer portal session request`, { userId, metadata: { endpoint } });
    if (!userId) return res.status(400).json({ success: false, error: "Missing userId." });
    try {
        const user = await User.findOne({ userId: userId });
        if (!user || !user.stripeCustomerId) {
            logDb('WARN', `User or Stripe Customer ID not found for portal access.`, { userId, metadata: { endpoint } });
            return res.status(404).json({ success: false, error: "No subscription found to manage, or user not synced with Stripe." });
        }
        const portalSession = await stripe.billingPortal.sessions.create({
            customer: user.stripeCustomerId,
            return_url: `${FRONTEND_URL}/popup/index.html#screen7` // Redirect to subscription screen in popup
        });
        logDb('INFO', `Stripe Customer Portal session created for user ${userId}`, { userId, metadata: { endpoint } });
        res.status(200).json({ success: true, url: portalSession.url });
    } catch (error) {
        logDb('ERROR', `Error creating Stripe customer portal session: ${error.message}`, { userId, metadata: { endpoint, errorDetails: error.stack } });
        res.status(500).json({ success: false, error: `Failed to create portal session: ${error.message}` });
    }
});

// --- Endpoint to START Generation (Async - Uses MongoDB Job) ---
app.post("/generate-async", async (req, res) => {
    const endpoint = '/generate-async';
    const { generationParams, userId } = req.body;
    logDb('INFO', `Generation request received`, { userId, metadata: { endpoint, params: generationParams?.linkedinUrls?.length + " URLs" }});

    let validationError = null;
    if (!userId) validationError = "Missing userId.";
    else if (!generationParams) validationError = "Missing generationParams.";
    else if (!Array.isArray(generationParams.linkedinUrls) || generationParams.linkedinUrls.length === 0) validationError = "linkedinUrls missing/empty.";
    else if (!generationParams.sequenceLength || typeof generationParams.sequenceLength !== 'number' || generationParams.sequenceLength <= 0) validationError = "Invalid sequenceLength.";
    else if (!generationParams.niche) validationError = "Missing niche selection.";
    else if (!OPENAI_API_KEY) validationError = "Server configuration error [OpenAI Key Missing]";

    if (validationError) {
        logDb('WARN', `Validation Error for User ${userId || 'N/A'}: ${validationError}`, { metadata: { endpoint } });
        return res.status(400).json({ success: false, error: validationError });
    }

    const requiredCredits = generationParams.linkedinUrls.length * generationParams.sequenceLength;
    let newCreditBalance = 0;
    try {
        const user = await User.findOne({ userId: userId });
        if (!user) {
            logDb('WARN', `Attempt to generate credits for non-existent user ${userId}.`, { metadata: { endpoint } });
            return res.status(400).json({ success: false, error: `User not found. Please refresh.` });
        }
        logDb('INFO', `Credit Check for ${userId} - Required: ${requiredCredits}, Available: ${user.credits}`, { metadata: { endpoint } });
        if (user.credits < requiredCredits) {
            logDb('WARN', `Insufficient credits for ${userId}. Required: ${requiredCredits}, Has: ${user.credits}`, { metadata: { endpoint } });
            return res.status(402).json({ success: false, error: `Insufficient credits. Required: ${requiredCredits}, Available: ${user.credits}.`, requiredCredits, availableCredits: user.credits });
        }
        const updatedUser = await User.findOneAndUpdate(
            { userId: userId, credits: { $gte: requiredCredits } },
            { $inc: { credits: -requiredCredits } }, { new: true }
        );
        if (!updatedUser) {
            const latestUser = await User.findOne({ userId: userId });
            logDb('WARN', `Failed to deduct credits for ${userId} (race condition?). Current: ${latestUser?.credits || 0}`, { metadata: { endpoint, required: requiredCredits } });
            return res.status(409).json({ success: false, error: `Credit deduction failed. Required: ${requiredCredits}, Available: ${latestUser?.credits || 0}. Try again.`, requiredCredits, availableCredits: latestUser?.credits || 0 });
        }
        newCreditBalance = updatedUser.credits;
        logDb('INFO', `Credits deducted for ${userId}: ${requiredCredits}. New balance: ${newCreditBalance}`, { metadata: { endpoint } });
    } catch (dbError) {
        logDb('ERROR', `DB error during credit check/deduction for ${userId}: ${dbError.message}`, { metadata: { endpoint, error: dbError }});
        return res.status(500).json({ success: false, error: "Internal server error checking credits." });
    }

    const numUrls = generationParams.linkedinUrls.length;
    const estimateBaseMs = 5000;
    const estimateScrapePerUrlMs = numUrls > 500 ? 12000 : 10000;
    const estimateAiPerUrlMs = numUrls > 500 ? 17000 : 15000;
    const estimatedTotalTimeMs = estimateBaseMs + numUrls * (estimateScrapePerUrlMs + estimateAiPerUrlMs);
    let jobId;
    try {
        const job = new Job({
            userId: userId, status: 'PENDING', params: generationParams,
            progress: { total: numUrls, processed: 0, status: 'Pending Start' },
            estimatedTimeMs: estimatedTotalTimeMs, expiresAt: new Date(Date.now() + JOB_TTL_MS)
        });
        await job.save();
        jobId = job._id.toString();
        logDb('INFO', `Job ${jobId} created in DB for User ${userId}. Status: PENDING`, { metadata: { endpoint } });
    } catch(dbError) {
        logDb('ERROR', `Failed to create job in DB for ${userId}: ${dbError.message}`, { metadata: { endpoint, error: dbError }});
        try { await User.updateOne({ userId: userId }, { $inc: { credits: requiredCredits }}); logDb('INFO', `Refunded ${requiredCredits} credits to ${userId} due to job creation failure.`, { metadata: { endpoint }}); }
        catch (refundError) { logDb('ERROR', `Failed to refund credits to ${userId}: ${refundError.message}`, { metadata: { endpoint, error: refundError }}); }
        return res.status(500).json({ success: false, error: 'Failed to initiate generation job.' });
    }

    res.status(202).json({
        success: true, message: "Generation job accepted.", jobId: jobId,
        estimatedTimeMs: estimatedTotalTimeMs, newCredits: newCreditBalance,
    });
    logDb('DEBUG', `Sent 202 Accepted for job ${jobId}. Estimate: ${estimatedTotalTimeMs}ms.`, { userId, metadata: { endpoint } });
    setImmediate(() => {
        logDb('DEBUG', `Starting performGeneration for job ${jobId} (User ${userId}) via setImmediate.`, { metadata: { endpoint } });
        performGeneration(jobId, generationParams, userId)
            .then(() => logDb('DEBUG', `performGeneration promise resolved for job ${jobId}.`, { metadata: { endpoint } }))
            .catch((err) => {
                logDb('ERROR', `UNHANDLED FATAL ERROR in performGeneration promise for job ${jobId}: ${err.message}`, { userId, metadata: { endpoint, error: err, stack: err.stack }});
                Job.findByIdAndUpdate(jobId, { $set: { status: 'ERROR', error: `Unexpected server error: ${err.message}`, completedAt: Date.now(), 'progress.status': 'Fatal Server Error'}}).catch(updateErr => logDb('ERROR', `Failed to mark job ${jobId} as ERROR: ${updateErr.message}`, { metadata: { endpoint, error: updateErr }}));
            });
    });
});

// --- Endpoint to GET Generation Status & Result ---
app.get("/generation-status/:jobId", async (req, res) => {
    const { jobId } = req.params;
    const endpoint = `/generation-status/${jobId}`;
    logDb('DEBUG', `Status request for job ${jobId}`, { metadata: { endpoint } });
    let job;
    try { job = await Job.findById(jobId); }
    catch (dbError) {
         if (dbError.name === 'CastError') { logDb('WARN', `Invalid Job ID format: ${jobId}`, { metadata: { endpoint, error: dbError }}); return res.status(400).json({ success: false, error: 'Invalid Job ID format.' }); }
         logDb('ERROR', `DB Error fetching job ${jobId}: ${dbError.message}`, { metadata: { endpoint, error: dbError }});
         return res.status(500).json({ success: false, error: 'Internal server error fetching job status.' });
    }
    if (!job) { logDb('WARN', `Job ${jobId} not found in DB.`, { metadata: { endpoint } }); return res.status(404).json({ success: false, error: 'Job not found.' }); }

    const responsePayload = {
        success: true, jobId: job._id.toString(), status: job.status,
        createdAt: job.createdAt, completedAt: job.completedAt,
        progress: job.progress || { total: 0, processed: 0, status: job.status },
        result: null, error: null, currentCredits: null
    };
    if (job.status === 'COMPLETE') responsePayload.result = job.result;
    else if (job.status === 'ERROR') { responsePayload.error = job.error; responsePayload.result = job.result; }
    else {
        try {
            const user = await User.findOne({ userId: job.userId });
            responsePayload.currentCredits = user?.credits ?? 0;
        } catch (dbError) {logDb('ERROR', `DB Error fetching current credits for user ${job.userId} (job ${jobId})`, {error: dbError}); responsePayload.currentCredits = 0;}
        responsePayload.result = {}; // Ensure result obj exists
    }
    res.status(200).json(responsePayload);
});

// --- Basic Root Route for Health Check ---
app.get("/", async (req, res) => {
    const dbStateVal = mongoose.connection.readyState;
    const dbStates = ['disconnected', 'connected', 'connecting', 'disconnecting', 'uninitialized'];
    let activeJobCount = 0; let dbPingStatus = 'pending'; let dbPingError = null;
    try {
        activeJobCount = await Job.countDocuments({ status: { $in: ['PENDING', 'RUNNING_SCRAPE', 'RUNNING_AI'] } });
        await mongoose.connection.db.admin().ping(); dbPingStatus = 'success';
        res.status(200).json({ status: "OK", dbState: dbStates[dbStateVal] || 'unknown', dbHost: mongoose.connection.host, dbName: mongoose.connection.name, dbPing: dbPingStatus, activeJobs: activeJobCount });
    } catch (err) {
        dbPingStatus = 'failed'; dbPingError = err.message;
        res.status(500).json({ status: "ERROR", dbState: dbStates[dbStateVal] || 'unknown', dbHost: mongoose.connection.host, dbPing: dbPingStatus, error: dbPingError, activeJobs: activeJobCount, connectionString: MONGODB_URI ? MONGODB_URI.substring(0, 25) + '...' : 'missing' });
    }
});

// Serve static HTML pages for payment status if you have them (optional)
// app.get("/subscription-success.html", (req, res) => res.sendFile(path.join(__dirname, "subscription-success.html")));
// app.get("/subscription-cancel.html", (req, res) => res.sendFile(path.join(__dirname, "subscription-cancel.html")));

// --- Start Server ---
const PORT = process.env.PORT || 3000;
app.listen(PORT, "0.0.0.0", () => {
    console.log(`-------------------------------------------------------`);
    console.log(` Sulian AI SDR Backend Service (RECURRING SUBSCRIPTIONS)`);
    console.log(`-------------------------------------------------------`);
    console.log(` Status: Server running on port ${PORT}`);
    console.log(` Stripe Lite Plan Price ID: ${STRIPE_LITE_PLAN_PRICE_ID || "NOT SET!"}`);
    console.log(` Stripe Pro Plan Price ID: ${STRIPE_PRO_PLAN_PRICE_ID || "NOT SET!"}`);
    console.log(` Frontend URL for Redirects: ${FRONTEND_URL}`);
    console.log(` MongoDB URI Set: ${MONGODB_URI ? 'Yes' : 'NO (CRITICAL!)'}`);
    console.log(`-------------------------------------------------------`);
});
// backend-server.js
require('dotenv').config();
const express = require("express");
const axios = require("axios");
const cors = require("cors");
const mongoose = require('mongoose'); // Re-added for user/credit storage

// --- Environment Variables & Validation ---
const APIFY_TOKEN = process.env.APIFY_TOKEN;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const MONGODB_URI = process.env.MONGO_URL;
const PORT = process.env.PORT || 3000;

// --- Constants ---
const INITIAL_CREDITS = 100; // Credits granted on first interaction

if (!MONGODB_URI) {
    console.error("FATAL: MONGODB_URI missing.");
    process.exit(1);
}
if (!OPENAI_API_KEY) {
    console.error("FATAL: OPENAI_API_KEY missing.");
    process.exit(1);
}
if (!APIFY_TOKEN) {
    console.warn("WARNING: APIFY_TOKEN not set. Scraping may fail.");
}

// --- Database Setup ---
mongoose.connect(MONGODB_URI)
    .then(() => console.log("MongoDB Connected Successfully."))
    .catch(err => {
        console.error("MongoDB Connection Error:", err);
        process.exit(1);
    });

// --- User Schema (Using generated userId) ---
const userSchema = new mongoose.Schema({
    userId: {
        type: String,
        required: true,
        unique: true,
        index: true
    }, // Unique ID generated by extension
    credits: {
        type: Number,
        default: INITIAL_CREDITS,
        min: 0
    },
    isActive: {
        type: Boolean,
        default: true
    },
    // Add other fields if needed (e.g., usage stats)
}, {
    timestamps: true
});

const User = mongoose.model('User', userSchema);

// --- Express App Setup ---
const app = express();
app.use(express.json());

// --- CORS Configuration ---
// IMPORTANT: Replace 'YOUR_EXTENSION_ID_HERE' if different
const extensionId = 'cddlnbjaagmmldhnkccjmnhmdkfngoji';
const extensionOrigin = `chrome-extension://${extensionId}`;
app.use(cors({
    origin: function(origin, callback) {
        if (!origin || origin === extensionOrigin) {
            callback(null, true);
        } else {
            console.warn(`CORS: Blocked origin: ${origin}`);
            callback(new Error('Not allowed by CORS'));
        }
    },
    methods: ["POST", "OPTIONS"],
    allowedHeaders: ["Content-Type", "X-User-ID"], // Allow custom User ID header
    optionsSuccessStatus: 200,
}));

// --- Middleware: Identify User (Get or Create) ---
const identifyUser = async (req, res, next) => {
    const userId = req.headers['x-user-id']; // Get ID generated by extension

    if (!userId || typeof userId !== 'string' || userId.length < 10) { // Basic validation
        return res.status(401).json({
            success: false,
            error: "Missing or invalid User ID header."
        });
    }

    try {
        // Find user OR create if not exists (upsert)
        const user = await User.findOneAndUpdate({
                userId: userId
            }, // Find criteria
            {
                $setOnInsert: { // Fields to set ONLY on insert (creation)
                    userId: userId,
                    credits: INITIAL_CREDITS, // Grant initial credits
                    isActive: true
                }
            }, {
                new: true, // Return the modified or new document
                upsert: true, // Create if document doesn't exist
                setDefaultsOnInsert: true // Apply default values from schema on creation
            }
        );

        if (!user) {
            // This should theoretically not happen with upsert: true, but handle defensively
            console.error(`User could not be found or created for userId: ${userId}`);
            return res.status(500).json({
                success: false,
                error: "Failed to identify or create user account."
            });
        }

        if (!user.isActive) {
            console.warn(`User account inactive: ${userId}`);
            return res.status(403).json({
                success: false,
                error: "User account is inactive."
            });
        }

        req.user = user; // Attach user object to the request
        console.log(`Identified user ${userId}. Credits: ${user.credits}`);
        next(); // Proceed

    } catch (dbError) {
        console.error("Database error during user identification:", dbError);
        return res.status(500).json({
            success: false,
            error: "Internal server error during user identification."
        });
    }
};


// --- Helper Functions (constructOpenAIPrompt, parseOpenAIResponse - Keep unchanged) ---
function constructOpenAIPrompt(generationParams, scrapedProfileData) {
    /* ... same as before ... */
    const escape = (str) => str ? String(str).replace(/`/g, "'").replace(/\n/g, " ").replace(/"/g, "'") : "";
    const {
        firstName,
        fullName,
        jobTitle,
        companyName,
        companyIndustry,
        addressWithoutCountry,
        addressWithCountry,
        about,
        updates,
        companySize,
        companyWebsite,
        url: profileUrl
    } = scrapedProfileData || {};
    const leadFirstName = escape(firstName) || "Prospect";
    const leadFullName = escape(fullName) || leadFirstName;
    const leadJobTitle = escape(jobTitle) || "N/A";
    const leadCompany = escape(companyName) || "N/A";
    const leadIndustry = escape(companyIndustry) || "N/A";
    const leadLocation = escape(addressWithoutCountry || addressWithCountry) || "N/A";
    const leadAbout = escape(about || "");
    const leadRecentPostSnippet = updates?.[0]?.postText ? escape(updates[0].postText.substring(0, 150)) + (updates[0].postText.length > 150 ? "..." : "") : "";
    const leadCompanySize = escape(companySize) || "N/A";
    const leadCompanyWebsite = escape(companyWebsite || "");
    const prompt = `
You are an expert B2B SDR writing a highly personalized cold email sequence using LinkedIn profile data. Your Goal: Write a ${generationParams.sequenceLength}-email sequence to initiate contact and achieve the goal: "${escape(generationParams.goal)}". Your Identity: - Name: ${escape(generationParams.fullName) || "Jake"} - Role: ${escape(generationParams.roleTitle) || "Founder"} - Website: ${escape(generationParams.website) || "yourcompany.com"} - Offer: ${escape(generationParams.offer) || "We provide valuable solutions."} - Industry: ${escape(generationParams.industry)} ${generationParams.caseStudy ? `- Case Study: ${escape(generationParams.caseStudy)}` : ""} ${generationParams.businessDescription ? `- Business Description: ${escape(generationParams.businessDescription)}` : ""} Prospect Info (from LinkedIn - ${escape(profileUrl || 'N/A')}): - First Name: ${leadFirstName} - Full Name: ${leadFullName} - Job Title: ${leadJobTitle} - Company: ${leadCompany} - Company Size: ${leadCompanySize} - Industry: ${leadIndustry} ${leadCompanyWebsite ? `- Website: ${leadCompanyWebsite}` : ""} - Location: ${leadLocation} ${leadAbout ? `- About Snippet: ${leadAbout.substring(0, 300)}${leadAbout.length > 300 ? "..." : ""}` : ""} ${leadRecentPostSnippet ? `- Recent Post Snippet: ${leadRecentPostSnippet}` : ""} Sequence Requirements: - Length: Exactly ${generationParams.sequenceLength} emails - Personalization: Subtly weave in the above details. Reference the source (${escape(profileUrl || 'their LinkedIn profile')}). - Tone: ${escape(generationParams.tone) || "Professional and helpful"} STRICT FORMAT: For each email: Start with ***EMAIL [Step Number]*** (e.g., ***EMAIL 1***) Subject line first: "Subject: [Your subject]" Body follows immediately on the next line. Start body with "Hi ${leadFirstName}," End with your name only: "${escape(generationParams.fullName) || "Jake"}" Begin generation now.
`;
    return prompt;
}

function parseOpenAIResponse(rawContent, expectedCount) {
    /* ... same as before ... */
    if (!rawContent) return [];
    const emails = [];
    const parts = rawContent.split(/\*{3,}\s*EMAIL\s+(\d+)\s*\*{3,}/i).slice(1);
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i].trim();
        if (!part) continue;
        const subjectMatch = part.match(/^Subject:\s*(.*)/im);
        const subject = subjectMatch ? subjectMatch[1].trim() : `Follow Up ${i + 1}`;
        const body = subjectMatch ? part.substring(subjectMatch.index + subjectMatch[0].length).trim() : part;
        if (emails.length < expectedCount) {
            emails.push({
                subject,
                body
            });
        } else {
            console.warn(`Parsed more emails than expected (${expectedCount}). Ignoring extra.`);
            break;
        }
    }
    while (emails.length < expectedCount) {
        console.warn(`Parsed only ${emails.length}/${expectedCount} emails. Padding with error.`);
        emails.push({
            subject: `Error Parsing Step ${emails.length + 1}`,
            body: `Could not parse email content for step ${emails.length + 1}.`
        });
    }
    return emails;
}


// --- Main Endpoint ---
// Apply the NEW user identification middleware
app.post("/scrape-linkedin", identifyUser, async (req, res) => {
    const startTime = Date.now();
    const user = req.user; // User object attached by middleware
    const {
        generationParams
    } = req.body;
    const warnings = [];

    // --- Basic Validation ---
    if (!generationParams || !Array.isArray(generationParams.linkedinUrls) || !generationParams.linkedinUrls.length) {
        return res.status(400).json({
            success: false,
            error: "linkedinUrls missing or empty in generationParams"
        });
    }
    const profileUrls = generationParams.linkedinUrls;
    const sequenceLength = parseInt(generationParams.sequenceLength, 10) || 3;

    // --- Credit Check & Deduction ---
    const costPerProfile = sequenceLength; // Cost based on sequence length
    const totalCost = profileUrls.length * costPerProfile;
    let newBalance = user.credits;

    console.log(`User ${user.userId}: Current Credits: ${user.credits}, Request Cost: ${totalCost}`);

    if (user.credits < totalCost) {
        console.warn(`Insufficient credits for user ${user.userId}. Required: ${totalCost}, Available: ${user.credits}`);
        return res.status(402).json({ // 402 Payment Required
            success: false,
            error: `Insufficient credits. Required: ${totalCost}, Available: ${user.credits}.`,
            newCredits: user.credits // Return current credits
        });
    }

    // Deduct Credits BEFORE processing
    try {
        newBalance = user.credits - totalCost;
        // Update user's credits in DB
        await User.updateOne({
            _id: user._id
        }, {
            credits: newBalance
        });
        console.log(`Deducted ${totalCost} credits. New balance for user ${user.userId}: ${newBalance}`);
    } catch (dbError) {
        console.error(`Failed to deduct credits for user ${user.userId}:`, dbError);
        return res.status(500).json({
            success: false,
            error: "Failed to update credit balance.",
            newCredits: user.credits
        });
    }
    // --- End Credit Check & Deduction ---


    const scrapedDataMap = new Map();
    // --- Step 1: Scrape via Apify (if token available) ---
    if (APIFY_TOKEN) {
        console.log(`Starting Apify scrape for ${profileUrls.length} URLs...`);
        try {
            /* ... Apify logic same as before ... */
            const apifyUrl = `https://api.apify.com/v2/acts/proxy_curl~linkedin-profile-scraper/run-sync-get-dataset-items?token=${APIFY_TOKEN}`;
            const apifyInput = {
                linkedin_profile_url: profileUrls,
                scrape_updates: 'true',
                max_updates_to_scrape: 1
            };

            const response = await axios.post(apifyUrl, apifyInput, {
                headers: {
                    "Content-Type": "application/json"
                },
                timeout: 300000
            });
            if (response.data && Array.isArray(response.data)) {
                console.log(`Apify returned ${response.data.length} results.`);
                response.data.forEach(item => {
                    const keyUrl = item.linkedin_profile_url || item.public_identifier || item.url || item.profile_url;
                    if (keyUrl) {
                        const originalUrl = profileUrls.find(orig => orig.includes(keyUrl.split('/').pop()));
                        if (originalUrl) scrapedDataMap.set(originalUrl, item);
                        else console.warn(`Could not map Apify result key ${keyUrl}.`);
                    } else console.warn("Apify item missing URL identifier:", item);
                });
                if (scrapedDataMap.size < profileUrls.length) warnings.push(`Apify only returned results for ${scrapedDataMap.size}/${profileUrls.length} profiles.`);
            } else warnings.push("Apify returned empty/invalid data.");
        } catch (error) {
            /* ... Apify error handling same as before ... */
            if (error.response) {
                console.error("Apify API Error:", error.response.status, error.response.data);
                warnings.push(`Apify scraping failed: ${error.response.status} - ${error.response.data?.error?.message || 'Unknown'}`);
            } else if (error.request) {
                console.error("Apify No Response:", error.message);
                warnings.push("Apify scraping failed: No response.");
            } else {
                console.error("Apify Setup Error:", error.message);
                warnings.push(`Apify scraping failed: ${error.message}`);
            }
            console.warn("Proceeding without Apify data.");
        }
    } else {
        warnings.push("APIFY_TOKEN not set. Skipping scraping.");
        console.log("Skipping Apify scraping.");
    }


    // --- Step 2: Generate Emails for each URL ---
    const generatedSequences = [];
    const generationPromises = profileUrls.map(async (url) => {
        /* ... OpenAI call logic same as before ... */
        const scrapedProfile = scrapedDataMap.get(url);
        const leadFirstName = scrapedProfile?.firstName || url.split('/').pop().split('-')[0] || "Prospect";
        const prompt = constructOpenAIPrompt(generationParams, scrapedProfile);
        try {
            console.log(`Calling OpenAI for: ${url}`);
            const openaiResponse = await axios.post("https://api.openai.com/v1/chat/completions", {
                model: "gpt-4",
                messages: [{
                    role: "user",
                    content: prompt
                }],
                temperature: 0.7,
                max_tokens: 2000
            }, {
                headers: {
                    "Authorization": `Bearer ${OPENAI_API_KEY}`,
                    "Content-Type": "application/json"
                },
                timeout: 60000
            });
            const rawContent = openaiResponse.data.choices[0]?.message?.content;
            if (!rawContent) throw new Error("OpenAI returned empty content.");
            const parsedEmails = parseOpenAIResponse(rawContent, sequenceLength);
            return {
                status: 'fulfilled',
                value: {
                    leadUrl: url,
                    leadName: leadFirstName,
                    emails: parsedEmails
                }
            };
        } catch (err) {
            let errorMsg = "OpenAI API call failed.";
            if (err.response) {
                console.error(`OpenAI API error for ${url}:`, err.response.status, err.response.data?.error?.message);
                errorMsg = `OpenAI Error (${err.response.status}): ${err.response.data?.error?.message || 'Unknown'}`;
            } else {
                console.error(`OpenAI request error for ${url}:`, err.message);
                errorMsg = `OpenAI Request Error: ${err.message}`;
            }
            warnings.push(`Failed sequence for ${url}: ${errorMsg}`);
            return {
                status: 'rejected',
                reason: errorMsg,
                leadUrl: url,
                leadName: leadFirstName
            };
        }
    });

    const results = await Promise.allSettled(generationPromises);
    results.forEach(result => {
        /* ... Processing results same as before ... */
        if (result.status === 'fulfilled') {
            generatedSequences.push(result.value);
        } else {
            generatedSequences.push({
                leadUrl: result.leadUrl,
                leadName: result.leadName,
                emails: Array(sequenceLength).fill(null).map((_, i) => ({
                    subject: `Error Generating Step ${i + 1}`,
                    body: `Failed generation.\nReason: ${result.reason}`
                }))
            });
        }
    });

    // --- Final Response ---
    const duration = (Date.now() - startTime) / 1000;
    console.log(`User ${user.userId}: Request completed in ${duration.toFixed(2)}s. Warnings: ${warnings.length}`);

    res.json({
        success: true,
        sequences: generatedSequences,
        newCredits: newBalance, // Send the updated balance
        warnings: warnings
    });
});

// --- Error Handling Middleware ---
app.use((err, req, res, next) => {
    /* ... same as before ... */
    console.error("Unhandled Error:", err);
    if (err.message === 'Not allowed by CORS') {
        res.status(403).json({
            success: false,
            error: 'Origin not allowed.'
        });
    } else {
        res.status(500).json({
            success: false,
            error: "Internal server error."
        });
    }
});

// --- Server Start ---
app.listen(PORT, () => {
    console.log(`🚀 Server running on http://localhost:${PORT}`);
    console.log(`✅ Accepting requests ONLY from origin: ${extensionOrigin} with X-User-ID header.`);
});